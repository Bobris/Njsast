namespace Njsast.Ast
{
    public static class Extensions
    {
        public static bool IsRequireSymbol(this SymbolDef? symbol)
        {
            return symbol != null && symbol.Undeclared && symbol.Global && symbol.Name == "require";
        }

        public static bool IsExportsSymbol(this SymbolDef? symbol)
        {
            return symbol != null && symbol.Undeclared && symbol.Global && symbol.Name == "exports";
        }

        public static bool IsPromiseSymbol(this SymbolDef? symbol)
        {
            return symbol != null && symbol.Undeclared && symbol.Global && symbol.Name == "Promise";
        }

        public static bool IsTsReexportSymbol(this SymbolDef? symbol)
        {
            return symbol != null && symbol.Undeclared && symbol.Global && symbol.Name == "__exportStar";
        }

        public static string? IsRequireCall(this AstNode node)
        {
            if (!(node is AstCall call) || call.Args.Count != 1 || !(call.Expression is AstSymbol methodNameSymbol) ||
                !methodNameSymbol.Thedef.IsRequireSymbol()) return null;
            var arg = call.Args[0];
            if (arg is AstString str)
                return str.Value;

            return null;
        }

        //Detect this pattern and success return require const parameter "./lib"
        //Promise.resolve().then(function() {
        //    return require("./lib");
        //})
        //Because this pattern is generated by TypeScript compiler when using: import("./lib")
        public static string? IsLazyImportCall(this AstNode node)
        {
            switch (node)
            {
                case AstImportExpression import:
                {
                    var arg = import.ModuleName;
                    if (arg is AstString str)
                        return str.Value;
                    return null;
                }
                case AstCall call when call.Args.Count == 1:
                {
                    var then = call.Expression;
                    if (then is AstDot dot && dot.Property as string == "then") {
                        if (dot.Expression is AstCall resolveCall && resolveCall.Args.Count == 0) {
                            if (resolveCall.Expression is AstDot resolveExpr && resolveExpr.Property as string == "resolve") {
                                var promiseRef = resolveExpr.Expression;
                                if (!(promiseRef is AstSymbolRef symbol) || !symbol.Thedef.IsPromiseSymbol()) return null;
                            } else return null;
                        } else return null;
                    } else return null;

                    if (
                        call.Args[0] is AstFunction argumentFunction &&
                        argumentFunction.ArgNames.Count == 0) {
                        if (argumentFunction.Body.Count == 1) {
                            if (argumentFunction.Body[0] is AstReturn returnStatement) return returnStatement.Value.IsRequireCall();
                        }
                    }

                    break;
                }
            }

            return null;
        }
    }
}
