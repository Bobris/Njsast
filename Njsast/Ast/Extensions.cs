using Njsast.Reader;

namespace Njsast.Ast
{
    public static class Extensions
    {
        static bool IsGlobalSymbol(SymbolDef? symbol, string name)
        {
            return symbol != null && symbol.Undeclared && symbol.Global && symbol.Name == name;
        }

        public static bool IsRequireSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol, "require");

        public static bool IsExportsSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol, "exports");

        public static bool IsPromiseSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol, "Promise");

        public static bool IsTsReexportSymbol(this SymbolDef? symbol) => IsGlobalSymbol(symbol, "__exportStar");

        public static string? IsRequireCall(this AstNode? node)
        {
            if (!(node is AstCall call) || call.Args.Count != 1 || !(call.Expression is AstSymbol methodNameSymbol) ||
                !methodNameSymbol.Thedef.IsRequireSymbol()) return null;
            var arg = call.Args[0];
            if (arg is AstString str)
                return str.Value;

            return null;
        }

        //Detect this pattern and success return require const parameter "./lib"
        //Promise.resolve().then(function() {
        //    return require("./lib");
        //})
        //Because this pattern is generated by TypeScript compiler when using: import("./lib")
        public static string? IsLazyImportCall(this AstNode node)
        {
            switch (node)
            {
                case AstImportExpression import:
                {
                    var arg = import.ModuleName;
                    if (arg is AstString str)
                        return str.Value;
                    return null;
                }
                case AstCall call when call.Args.Count == 1:
                {
                    var then = call.Expression;
                    if (then is AstDot dot && dot.Property as string == "then")
                    {
                        if (dot.Expression is AstCall resolveCall && resolveCall.Args.Count == 0)
                        {
                            if (resolveCall.Expression is AstDot resolveExpr &&
                                resolveExpr.Property as string == "resolve")
                            {
                                var promiseRef = resolveExpr.Expression;
                                if (!(promiseRef is AstSymbolRef symbol) || !symbol.Thedef.IsPromiseSymbol())
                                    return null;
                            }
                            else return null;
                        }
                        else return null;
                    }
                    else return null;

                    if (
                        call.Args[0] is AstFunction argumentFunction &&
                        argumentFunction.ArgNames.Count == 0)
                    {
                        if (argumentFunction.Body.Count == 1)
                        {
                            if (argumentFunction.Body[0] is AstReturn returnStatement)
                                return returnStatement.Value.IsRequireCall();
                        }
                    }

                    break;
                }
            }

            return null;
        }

        public static SymbolDef? IsSymbolDef(this AstNode? node)
        {
            if (node is AstSymbol symbol) return symbol.Thedef;
            return null;
        }

        public static (string name, AstNode? value)? IsExportsAssign(this AstNode node)
        {
            if (!(node is AstAssign assign)) return null;
            if (assign.Operator != Operator.Assignment) return null;
            if (!(assign.Left is AstPropAccess propAccess)) return null;
            if (!propAccess.Expression.IsSymbolDef().IsExportsSymbol())
                return null;
            var name = propAccess.PropertyAsString;
            if (name != null)
                return (name, assign.Right);
            return null;
        }

        /// return true is parameter is Object.defineProperty(exports, "__esModule", { value: true })
        public static bool IsDefinePropertyExportsEsModule(this AstCall call)
        {
            if (call.Args.Count != 3 || !call.Args[0].IsSymbolDef().IsExportsSymbol()) return false;
            if (!(call.Expression is AstPropAccess propAccess)) return false;
            if (propAccess.PropertyAsString != "defineProperty") return false;
            return IsGlobalSymbol(propAccess.Expression.IsSymbolDef(), "Object");
        }

        public static bool IsConstantSymbolRef(this AstNode? node)
        {
            var def = node.IsSymbolDef();
            if (def == null) return false;
            if (def.Undeclared) return false;
            if (def.Orig.Count != 1) return false;
            return def.Orig[0] is AstSymbolDefun || (def.Orig[0].ConstValue() != null);
        }
    }
}
